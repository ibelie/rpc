// Copyright 2017 ibelie, Chen Jie, Joungtao. All rights reserved.
// Use of this source code is governed by The MIT License
// that can be found in the LICENSE file.

package rpc

import (
	"bytes"
	"fmt"
	"log"
	"path"
	"regexp"
	"strings"

	"io/ioutil"

	"github.com/ibelie/tygo"
)

func Typescript(input string, tsOut string, goOut string) {
	text, err := ioutil.ReadFile(input)
	if err != nil {
		log.Fatalf("[RPC][Typescript] Cannot read file:\n>>>>%v", err)
		return
	}

	componentReg := regexp.MustCompile(`([_\d\w]+)\s*:\s*([\._\d\w]+)\s*;`)
	entityReg := regexp.MustCompile(`class\s+([_\d\w]+)\s+extends\s+ibelie.rpc.Entity\s*{`)
	entityText := entityReg.Split(string(text), -1)
	entityMap := make(map[string]map[string][]string)
	for i, e := range entityReg.FindAllStringSubmatch(string(text), -1) {
		entityMap[e[1]] = make(map[string][]string)
		for _, c := range componentReg.FindAllStringSubmatch(entityText[i+1], -1) {
			if !strings.HasSuffix(c[2], c[1]) {
				continue
			}
			pkg := strings.Replace(c[2][:len(c[2])-len(c[1])-1], ".", "/", -1)
			entityMap[e[1]][pkg] = append(entityMap[e[1]][pkg], c[1])
		}
	}

	entities, types := resolveEntities(entityMap)
	objects := make(map[string]*tygo.Object)
	for _, t := range types {
		if object, ok := t.(*tygo.Object); ok {
			if o, exist := objects[object.Name]; exist {
				log.Fatalf("[RPC][Typescript] Object already exists: %v %v", o, object)
			}
			objects[object.Name] = object
		}
	}

	tygo.Typescript(tsOut, "types", "ibelie.rpc", types, []tygo.Type{tygo.SimpleType_UINT64, tygo.SimpleType_UINT64})
	injectJavascript(tsOut, entities)
	injectTypescript(tsOut, entities, objects)
}

func injectTypescript(dir string, entities []*Entity, objects map[string]*tygo.Object) {
	var buffer bytes.Buffer
	var methods []string
	for _, e := range entities {
		methodsMap := make(map[string]bool)
		for _, c := range e.Components {
			for _, m := range c.Methods {
				if ok, exist := methodsMap[m.Name]; exist && ok {
					continue
				} else if len(m.Results) > 0 {
					continue
				}
				var params []string
				for i, p := range m.Params {
					params = append(params, fmt.Sprintf("a%d: %s", i, p.Typescript(objects, nil)))
				}
				methods = append(methods, fmt.Sprintf(`
		%s(%s): void;`, m.Name, strings.Join(params, ", ")))
				methodsMap[m.Name] = true
			}
		}
	}

	buffer.Write([]byte(fmt.Sprintf(`// Generated by ibelie-rpc.  DO NOT EDIT!

declare module ibelie.rpc {
	class Entity {
		__class__: string;
		isAwake: boolean;
		Awake(): void;
		Sleep(): void;
		ByteSize(): number;
		Serialize(): Uint8Array;
		Deserialize(data: Uint8Array): void;%s
	}

	class Component {
		Entity: Entity;
		constructor(entity: Entity);
	}
}
`, strings.Join(methods, ""))))

	ioutil.WriteFile(path.Join(dir, "rpc.d.ts"), buffer.Bytes(), 0666)
}
