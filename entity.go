// Copyright 2017 ibelie, Chen Jie, Joungtao. All rights reserved.
// Use of this source code is governed by The MIT License
// that can be found in the LICENSE file.

package rpc

import (
	"bytes"
	"fmt"
	"path"
	"sort"
	"strings"

	"io/ioutil"

	"github.com/ibelie/tygo"
)

var (
	ENTITY_PKG = map[string]string{
		"github.com/ibelie/ruid": "",
		"github.com/ibelie/tygo": "",
	}
	builtinSymbols = []string{
		"CREATE",
		"DESTROY",
		"SYNCHRON",
		"NOTIFY",
	}
)

const (
	SERVER_CODE = `
type IServer interface {
	Distribute(ruid.RUID, ruid.RUID, uint64, uint64, []byte, chan<- []byte) error
	Procedure(ruid.RUID, ruid.RUID, uint64, uint64, []byte) ([]byte, error)
}

var Server IServer
var Symbols map[string]uint64
`
	ENTITY_CODE = `
type Entity struct {
	tygo.Tygo
	ruid.RUID
	Key  ruid.RUID
	Type uint64
}

func NewEntity(i ruid.RUID, k ruid.RUID, t string) *Entity {
	return &Entity{RUID: i, Key: k, Type: Symbols[t]}
}

func (e *Entity) Create() error {
	data := make([]byte, tygo.SizeVarint(uint64(e.Key))+tygo.SizeVarint(e.Type))
	output := &tygo.ProtoBuf{Buffer: data}
	output.WriteVarint(uint64(e.Key))
	output.WriteVarint(e.Type)
	return Server.Distribute(e.RUID, e.Key, e.Type, SYMBOL_CREATE, data, nil)
}

func (e *Entity) Destroy() error {
	return Server.Distribute(e.RUID, e.Key, e.Type, SYMBOL_DESTROY, nil, nil)
}

func (e *Entity) ByteSize() (size int) {
	if e != nil {
		size = tygo.SizeVarint(uint64(e.RUID)) + tygo.SizeVarint(uint64(e.Key)) + tygo.SizeVarint(e.Type)
		e.SetCachedSize(size)
	}
	return
}

func (e *Entity) Serialize(output *tygo.ProtoBuf) {
	if e != nil {
		output.WriteVarint(uint64(e.RUID))
		output.WriteVarint(uint64(e.Key))
		output.WriteVarint(e.Type)
	}
}

func (e *Entity) Deserialize(input *tygo.ProtoBuf) (err error) {
	var i, k uint64
	if i, err = input.ReadVarint(); err != nil {
		return
	} else if k, err = input.ReadVarint(); err != nil {
		return
	} else if e.Type, err = input.ReadVarint(); err != nil {
		return
	}
	e.RUID = ruid.RUID(i)
	e.Key = ruid.RUID(k)
	return
}
`
)

func Go(dir string, types []tygo.Type) {
	pkgname, depends := Extract(dir)
	pkgs := ENTITY_PKG
	var head bytes.Buffer
	var body bytes.Buffer
	head.Write([]byte(fmt.Sprintf(`// Generated by ibelie-rpc.  DO NOT EDIT!

package %s
`, pkgname)))
	body.Write([]byte(`
`))
	body.Write([]byte(SERVER_CODE))
	body.Write([]byte(ENTITY_CODE))

	var services []*tygo.Object
	for _, t := range types {
		if object, ok := isService(t); ok {
			services = append(services, object)
		}
	}

	for _, depend := range depends {
		for _, t := range tygo.Extract(depend.Path, nil) {
			for _, s := range depend.Services {
				if object, ok := isService(t); ok {
					if s == object.Name {
						var methods []string
						services = append(services, object)
						for _, method := range object.Methods {
							if len(method.Params) > 0 {
								param_s, param_p := tygo.TypeListSerialize(object.Name+DELEGATE, method.Name, "param", method.Params)
								pkgs = update(pkgs, param_p)
								methods = append(methods, param_s)
							}
							if len(method.Results) > 0 {
								result_s, result_p := tygo.TypeListDeserialize(object.Name+DELEGATE, method.Name, "result", method.Results)
								pkgs = update(pkgs, result_p)
								methods = append(methods, result_s)
							}
							method_s, method_p := injectProcedureCaller(object.Name+DELEGATE, object.Name, method, "")
							pkgs = update(pkgs, method_p)
							methods = append(methods, method_s)
						}

						body.Write([]byte(fmt.Sprintf(`
type %sDelegate Entity

func (e *Entity) %s() *%sDelegate {
	return (*%sDelegate)(e)
}
%s`, object.Name, object.Name, object.Name, object.Name, strings.Join(methods, ""))))
					}
				}
			}
		}
	}

	init_s, init_p := entityInitialize(services)
	body.Write([]byte(init_s))
	pkgs = update(pkgs, init_p)

	methodRecord := make(map[string]bool)
	for _, s := range services {
		for _, m := range s.Methods {
			if ok, exist := methodRecord[m.Name]; exist && ok {
				continue
			} else if len(m.Results) > 1 {
				continue
			}
			method_s, method_p := entityDistribute(s, m)
			body.Write([]byte(method_s))
			pkgs = update(pkgs, method_p)
			methodRecord[m.Name] = true
		}
	}

	var sortedPkg []string
	for pkg, _ := range pkgs {
		sortedPkg = append(sortedPkg, pkg)
	}
	sort.Strings(sortedPkg)
	for _, pkg := range sortedPkg {
		head.Write([]byte(fmt.Sprintf(`
import %s"%s"`, pkgs[pkg], pkg)))
	}

	head.Write(body.Bytes())
	ioutil.WriteFile(path.Join(SRC_PATH, dir, "entity.rpc.go"), head.Bytes(), 0666)
}

func Symbols(dir string, entities []*Entity) {
	maxSymbol := 0
	symbolMap := make(map[string]bool)
	for _, e := range entities {
		symbolMap[e.Name] = true
		for _, c := range e.Components {
			symbolMap[c.Name] = true
			for _, f := range c.Fields {
				symbolMap[f.Name] = true
			}
			for _, m := range c.Methods {
				symbolMap[m.Name] = true
			}
		}
	}

	var symbolConsts []string
	for i, s := range builtinSymbols {
		if maxSymbol < len(s) {
			maxSymbol = len(s)
		}
		if i == 0 {
			symbolConsts = append(symbolConsts, fmt.Sprintf(`
	SYMBOL_%s uint64 = iota`, s))
		} else {
			symbolConsts = append(symbolConsts, fmt.Sprintf(`
	SYMBOL_%s`, s))
		}
	}

	var symbolSorted []string
	for s, ok := range symbolMap {
		if !ok {
			continue
		}
		if maxSymbol < len(s) {
			maxSymbol = len(s)
		}
		symbolSorted = append(symbolSorted, s)
	}
	sort.Strings(symbolSorted)

	var symbolValues []string
	for _, s := range builtinSymbols {
		symbolValues = append(symbolValues, fmt.Sprintf(`
	"%s": %sSYMBOL_%s,`, s, strings.Repeat(" ", maxSymbol-len(s)), s))
	}
	for _, s := range symbolSorted {
		symbolConsts = append(symbolConsts, fmt.Sprintf(`
	SYMBOL_%s`, s))
		symbolValues = append(symbolValues, fmt.Sprintf(`
	"%s": %sSYMBOL_%s,`, s, strings.Repeat(" ", maxSymbol-len(s)), s))
	}

	ioutil.WriteFile(path.Join(dir, "symbol.tbl.go"), []byte(fmt.Sprintf(`// Generated by ibelie-rpc.  DO NOT EDIT!

package main

const (%s
)

var Symbols = map[string]uint64{%s
}
`, strings.Join(symbolConsts, ""), strings.Join(symbolValues, ""))), 0666)
}

func Routes(dir string, entities []*Entity) {
	var routes []string
	methodMap := make(map[string][]string)
	for _, e := range entities {
		var components []string
		for _, c := range e.Components {
			components = append(components, fmt.Sprintf(`
		SYMBOL_%s: true,`, c.Name))
			for _, m := range c.Methods {
				methodMap[m.Name] = append(methodMap[m.Name], c.Name)
			}
		}
		routes = append(routes, fmt.Sprintf(`
	SYMBOL_%s: map[uint64]bool{%s
	},`, e.Name, strings.Join(components, "")))
	}

	var methodSorted []string
	for m, _ := range methodMap {
		methodSorted = append(methodSorted, m)
		sort.Strings(methodMap[m])
	}
	sort.Strings(methodSorted)
	for _, m := range methodSorted {
		var components []string
		for _, c := range methodMap[m] {
			components = append(components, fmt.Sprintf(`
		SYMBOL_%s: true,`, c))
		}
		routes = append(routes, fmt.Sprintf(`
	SYMBOL_%s: map[uint64]bool{%s
	},`, m, strings.Join(components, "")))
	}

	ioutil.WriteFile(path.Join(dir, "route.tbl.go"), []byte(fmt.Sprintf(`// Generated by ibelie-rpc.  DO NOT EDIT!

package main

var Routes = map[uint64]map[uint64]bool{%s
}
`, strings.Join(routes, ""))), 0666)
}

func entityInitialize(services []*tygo.Object) (string, map[string]string) {
	maxSymbol := 0
	symbolMap := make(map[string]bool)
	for _, s := range services {
		symbolMap[s.Name] = true
		for _, f := range s.Fields {
			symbolMap[f.Name] = true
		}
		for _, m := range s.Methods {
			symbolMap[m.Name] = true
		}
	}

	var symbolSorted []string
	for s, ok := range symbolMap {
		if !ok {
			continue
		}
		if maxSymbol < len(s) {
			maxSymbol = len(s)
		}
		symbolSorted = append(symbolSorted, s)
	}
	sort.Strings(symbolSorted)

	var symbolDeclare []string
	var symbolInitialize []string
	for _, s := range symbolSorted {
		symbolDeclare = append(symbolDeclare, fmt.Sprintf(`
	SYMBOL_%s %suint64`, s, strings.Repeat(" ", maxSymbol-len(s))))
		symbolInitialize = append(symbolInitialize, fmt.Sprintf(`
		SYMBOL_%s = Symbols["%s"]`, s, s))
	}

	var symbolConst []string
	for i, s := range builtinSymbols {
		if i == 0 {
			symbolConst = append(symbolConst, fmt.Sprintf(`
	SYMBOL_%s uint64 = iota`, s))
		} else {
			symbolConst = append(symbolConst, fmt.Sprintf(`
	SYMBOL_%s`, s))
		}
	}

	return fmt.Sprintf(`
const (%s
)

var (%s
)

func InitializeServer(server IServer, symbols map[string]uint64) {
	if Server == nil {
		Server = server
	}
	if Symbols == nil {
		Symbols = symbols%s
	}
}
`, strings.Join(symbolConst, ""), strings.Join(symbolDeclare, ""), strings.Join(symbolInitialize, "")), nil
}

func entityDistribute(service *tygo.Object, method *tygo.Method) (string, map[string]string) {
	var pkgs map[string]string
	var param string
	var params_list []string
	var params_declare []string
	for i, p := range method.Params {
		param_s, param_p := p.Go()
		pkgs = update(pkgs, param_p)
		params_list = append(params_list, fmt.Sprintf("p%d", i))
		params_declare = append(params_declare, fmt.Sprintf("p%d %s", i, param_s))
	}

	if len(params_list) > 0 {
		param = fmt.Sprintf("(*%sDelegate)(nil).Serialize%sParam(%s)",
			service.Name, method.Name, strings.Join(params_list, ", "))
	} else {
		param = "nil"
	}

	var result string
	if len(method.Results) == 1 {
		result_s, result_p := method.Results[0].Go()
		pkgs = update(pkgs, result_p)
		params_declare = append(params_declare, fmt.Sprintf("rChan chan<- %s", result_s))
		result = fmt.Sprintf(`
	if rChan != nil {
		var err error
		resultChan := make(chan []byte)
		go func() {
			if err = Server.Distribute(e.RUID, e.Key, e.Type, SYMBOL_%s, %s, resultChan); err == nil {
				for result := range resultChan {
					var r %s
					r, err = (*%sDelegate)(nil).Deserialize%sResult(result)
					rChan <- r
				}
			}
			close(rChan)
		}()
		return err
	} else {
		return Server.Distribute(e.RUID, e.Key, e.Type, SYMBOL_%s, %s, nil)
	}`, method.Name, param, result_s, service.Name, method.Name, method.Name, param)
	} else {
		result = fmt.Sprintf(`
	return Server.Distribute(e.RUID, e.Key, e.Type, SYMBOL_%s, %s, nil)`,
			method.Name, param)
	}

	return fmt.Sprintf(`
func (e *Entity) %s(%s) error {%s
}
`, method.Name, strings.Join(params_declare, ", "), result), pkgs
}
